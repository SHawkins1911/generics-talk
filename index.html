<!DOCTYPE html><html><head><title>Generics 101</title><meta charset="utf-8"><script src="slides.js"></script><link href="https://fonts.googleapis.com/css?family=Gravitas+One|Yeseva+One" rel="stylesheet"><link href="styles.css" rel="stylesheet" type="text/css"></head><body><section class="slides layout-regular template-default"><article class="first"><h3><img src="images/sink.svg" width="300"><img src="images/weight.svg" width="300"></h3><h1><mark>Generics 101</mark></h1><p></p><p></p><p style="margin:0;" class="sub yellow">I hope you like this talk</p></article><article><h1><mark>I&apos;m Ahmad </mark></h1><p><br></p><p class="sub build"><span>Cohort 4.1 <br></span><span>CTO @ JPMC <br></span><span>JavaScript, Go, C <br></span></p></article><article class="first"><h3><img src="images/sink.svg" width="300"><img src="images/weight.svg" width="300"></h3><h1><mark class="build"><span>Generics</span><span>???</span></mark></h1></article><article><h1>Generics are hard to grasp</h1></article><article class="section"><h1>Bugs</h1><p class="sub">They are always looking for a friend to hang out with</p></article><article><h2 class="skew"><mark class="build">Not all bugs are created equal. Compile-time bugs are much friendlier than runtime bugs.</mark></h2></article><article><ul class="build"><li>Compile-time bugs are easier to detect early on.</li><li>The compiler will tell you when and where a bug occurs.</li><li>Runtime bugs will wait until 3 days after you push to prod before exploding.</li><li>Then you are going to have to respond to 500+ support emails.</li><li>You don't want to respond to 500+ support emails.</li></ul></article><article><h2 class="skew"><mark>Okay, I get it.</mark></h2></article><article><h1>But what do bugs have to do with generics?</h1></article><article><h1>Generics will save you from runtime bugs!</h1></article><article><h1>How?</h1></article><article><h2 class="title"><mark>Benefits to using generic code:</mark></h2><ul class="build"><li>Stronger type checks at compile time</li><li>Elimination of casting</li><li>Generic algorithms</li><li>And much more...</li></ul></article><article><p><mark>Imagine we had a spoon that could be used for eating cereal, soup, or oatmeal.</mark></p></article><article><h2><mark>It already exists!</mark></h2><p>Does it make sense to have a different spoon for each type?</p></article><article><h1>NO</h1></article><article><img src="./examples/ex1.png" class="wide"></article><article><img src="./examples/ex3.png" class="high"></article><article><h2>pls.</h2></article><article><img src="./examples/ex2.png" class="wide"></article><article><img src="./examples/ex4.png" class="wide"></article><article><h2><mark>Bounded types</mark></h2></article><article><img src="./examples/ex5.png" class="high"></article><article><img src="./examples/ex6.png" class="high"></article><article><h2><mark>Generic Methods?</mark></h2></article><article><img src="./examples/ex7.png" class="wide"></article><article><h2><mark>Wildcards</mark></h2><p class="sub flat">For when you don't exactly know, but sort of know, but not really</p></article><article><h1>Upper bounded, lower bounded, and unbounded</h1></article><article><img src="./examples/ex8.png" class="wide"></article><article><img src="./examples/ex9.png" class="wide"></article><article><img src="./examples/ex10.png" class="wide"></article><article><h2><mark>This is as far as you need to go</mark></h2></article><article class="section"><h1>buuuuuuttt</h1></article><article class="section"><ul class="build"><li>Type erasure</li><li>Wildcard capture and helper methods</li><li>Bridge/Synthetic methods</li><li>Non-reifiable types and heap pollution</li><li>Generic restrictions</li><span>(okay... maybe you should look at generic restrictions)</span></ul></article><article><h1><mark>Thanks!</mark></h1><p class="sub"><a>github.com/woat</a></p></article></section></body></html>